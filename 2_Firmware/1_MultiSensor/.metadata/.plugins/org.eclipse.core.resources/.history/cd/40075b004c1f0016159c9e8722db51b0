 /*            #                                                   
             #@#@                                                   
          @@@#@@@                                                   
          @ `@@                                                     
          @@                                                        
          @@@                                                       
      .    @@                                                       
     @@@@. @@    @@          @@        @@,@;       @@  :@@@@@@@     
    @@@@@@@'@   @@@          #@`      '@  @@       @@  :@   .@@@.   
    @@@@@@@ @:  @@@           @@      @@  @@      `@:  :@`     @@   
    @@@@@@@@@@@@@@@           @@      @+  .@'     @@   :@`      @@  
    @@@@@@@@@@@@@@@           +@`    +@    @@     @@   :@`      @@  
    @@@@@@@@@@@@@@@            @@    @@    @@    `@.   :@`      @@  
    @@@@@@@@@@@@@@@            @@    @'     @#   @@    :@`      #@  
    @@@@@@@@@@@@@@@,           ;@.  +@      @@   @@    :@`      @@  
   @@@@@@@@@@@@@@@@@            @@  @@      #@  `@`    :@`      @@  
   @@@@@@@@@@@@@@@@@@           @@  @:       @# @@     :@`      @@  
  '@@@@@@@@@@@@@@@@@@           ,@,+@        @@ @@     :@`     ;@+  
  '@@@@+@@@@@@@@@@@@@            @@@@        +@`@      :@`    ,@@   
   @@@  @@@@@@ @@@@@#            @@@.         @@@      :@@@@@@@@    
        @@@@@@  :+:              `@@          @@+      `@@@@@@      
        @@@@@@                                                      
        @@@@@@                                                      
 */

/**
 * Valere Versnip Design 
 *
 * @project MultiSensor_bsp
 * @file adc.c
 * @author TimB
 * @date 18-mei-2016
 * @brief	Low level routines for adc access.
 *
 * adc initialization and low level routines.
 */

/* ***********************************************************************************************************************************************
 * Include Files
 * ***********************************************************************************************************************************************
 */
#include "adc.h"
#include "lowleveldriversconfig.h"
/*
 * ***********************************************************************************************************************************************
 * Defines
 * ***********************************************************************************************************************************************
 */


/*
 * ***********************************************************************************************************************************************
 * Local Members
 * ***********************************************************************************************************************************************
 */



#if LOWLEVELDRIVERSCONFIG_ADC0_USE
static RINGBUFF_T AdcRingBuffer0;												/**< adc0 ringbuffer */
static uint16_t AdcBuff0[ADC_BUFFERSIZE];										/**< adc0 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC1_USE
static RINGBUFF_T AdcRingBuffer1;												/**< adc1 ringbuffer */
static uint16_t AdcBuff1[ADC_BUFFERSIZE];										/**< adc1 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC2_USE
static RINGBUFF_T AdcRingBuffer2;												/**< adc2 ringbuffer */
static uint16_t AdcBuff2[ADC_BUFFERSIZE];										/**< adc2 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC3_USE
static RINGBUFF_T AdcRingBuffer3;												/**< adc3 ringbuffer */
static uint16_t AdcBuff3[ADC_BUFFERSIZE];										/**< adc3 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC4_USE
static RINGBUFF_T AdcRingBuffer4;												/**< adc4 ringbuffer */
static uint16_t AdcBuff4[ADC_BUFFERSIZE];										/**< adc4 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC5_USE
static RINGBUFF_T AdcRingBuffer5;												/**< adc5 ringbuffer */
static uint16_t AdcBuff5[ADC_BUFFERSIZE];										/**< adc5 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC6_USE
static RINGBUFF_T AdcRingBuffer6;												/**< adc6 ringbuffer */
static uint16_t AdcBuff6[ADC_BUFFERSIZE];										/**< adc6 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC7_USE
static RINGBUFF_T AdcRingBuffer7;												/**< adc7 ringbuffer */
static uint16_t AdcBuff7[ADC_BUFFERSIZE];										/**< adc7 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC8_USE
static RINGBUFF_T AdcRingBuffer8;												/**< adc8 ringbuffer */
static uint16_t AdcBuff8[ADC_BUFFERSIZE];										/**< adc8 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC9_USE
static RINGBUFF_T AdcRingBuffer9;												/**< adc9 ringbuffer */
static uint16_t AdcBuff9[ADC_BUFFERSIZE];										/**< adc9 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC10_USE
static RINGBUFF_T AdcRingBuffer10;												/**< adc10 ringbuffer */
static uint16_t AdcBuff10[ADC_BUFFERSIZE];										/**< adc10 data buffer */
#endif

#if LOWLEVELDRIVERSCONFIG_ADC11_USE
static RINGBUFF_T AdcRingBuffer11;												/**< adc11 ringbuffer */
static uint16_t AdcBuff11[ADC_BUFFERSIZE];										/**< adc11 data buffer */
#endif




/*
 * ***********************************************************************************************************************************************
 * Private Function Prototypes
 * ***********************************************************************************************************************************************
 */

/**
 * Get the pointer to the adc channel ringbuffer.
 *
 * Returns NULL if the channel is not enabled!.
 * @param p_adc	adc device
 * @param channel channel (0-11)
 * @return	pinter to ringbuffer, or NULL if channel is not enabled, or not found.
 */
RINGBUFF_T* adc_getringbuffer(adc_t *p_adc, uint8_t channel);

/*
 * ***********************************************************************************************************************************************
 * Private Functions
 * ***********************************************************************************************************************************************
 */

/**
 * Get the pointer to the adc channel ringbuffer.
 *
 * Returns NULL if the channel is not enabled!.
 * @param p_adc	adc device
 * @param channel channel (0-11)
 * @return	pinter to ringbuffer, or NULL if channel is not enabled, or not found.
 */
RINGBUFF_T* adc_getringbuffer(adc_t *p_adc, uint8_t channel)
{
	RINGBUFF_T *p_ringbuffer;

	/* get ringbuffer */
	switch(channel)
	{
#if LOWLEVELDRIVERSCONFIG_ADC0_USE
	case 0:
		p_ringbuffer = &AdcRingBuffer0;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC1_USE
	case 1:
		p_ringbuffer = &AdcRingBuffer1;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC2_USE
	case 2:
		p_ringbuffer = &AdcRingBuffer2;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC3_USE
	case 3:
		p_ringbuffer = &AdcRingBuffer3;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC4_USE
	case 4:
		p_ringbuffer = &AdcRingBuffer4;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC5_USE
	case 5:
		p_ringbuffer = &AdcRingBuffer5;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC6_USE
	case 6:
		p_ringbuffer = &AdcRingBuffer6;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC7_USE
	case 7:
		p_ringbuffer = &AdcRingBuffer7;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC8_USE
	case 8:
		p_ringbuffer = &AdcRingBuffer8;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC9_USE
	case 9:
		p_ringbuffer = &AdcRingBuffer9;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC10_USE
	case 10:
		p_ringbuffer = &AdcRingBuffer10;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC11_USE
	case 11:
		ingbuffer = &AdcRingBuffer11;
		break;
#endif
	default:
		p_ringbuffer = NULL;
		break;
	}
	return p_ringbuffer;
}


void adc_setupringbuffers()
{
#if LOWLEVELDRIVERSCONFIG_ADC0_USE
	RingBuffer_Init(&AdcRingBuffer0, AdcBuff0, 1, ADC_BUFFERSIZE);
#endif
#if LOWLEVELDRIVERSCONFIG_ADC1_USE
	case 1:
		p_ringbuffer = &AdcRingBuffer1;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC2_USE
	case 2:
		p_ringbuffer = &AdcRingBuffer2;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC3_USE
	case 3:
		p_ringbuffer = &AdcRingBuffer3;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC4_USE
	case 4:
		p_ringbuffer = &AdcRingBuffer4;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC5_USE
	case 5:
		p_ringbuffer = &AdcRingBuffer5;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC6_USE
	case 6:
		p_ringbuffer = &AdcRingBuffer6;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC7_USE
	case 7:
		p_ringbuffer = &AdcRingBuffer7;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC8_USE
	case 8:
		p_ringbuffer = &AdcRingBuffer8;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC9_USE
	case 9:
		p_ringbuffer = &AdcRingBuffer9;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC10_USE
	case 10:
		p_ringbuffer = &AdcRingBuffer10;
		break;
#endif
#if LOWLEVELDRIVERSCONFIG_ADC11_USE
	case 11:
		ingbuffer = &AdcRingBuffer11;
		break;
#endif
}


/*
 * ***********************************************************************************************************************************************
 * Public Functions
 * ***********************************************************************************************************************************************
 */

status_t ADC_Init(adc_t *p_adc, adc_config_t *p_config)
{
	status_t status = status_ok;
	uint8_t i;
	/* populate struct */
	for(i = 0; i < ADC_CHANNELAMOUNT; i++)
	{
		p_adc->usechannel[i]	= p_config->usechannel[i];
		/* only if the channel is used, set the pointer, otherwise set null */
		p_adc->p_ringbuffer[i] = adc_getringbuffer(p_adc, i);
	}

	/* setup the ringbuffers */


	/* Setup ADC for 12-bit mode and normal power */
		Chip_ADC_Init(LPC_ADC, 0);

	/* Need to do a calibration after initialization and trim */
	Chip_ADC_StartCalibration(LPC_ADC);
	while (!(Chip_ADC_IsCalibrationDone(LPC_ADC))) {}

	/* Setup for maximum ADC clock rate using sycnchronous clocking */
	Chip_ADC_SetClockRate(LPC_ADC, ADC_MAX_SAMPLE_RATE);


	return status;
}

/* End of file adc.c */
